本章前面是关于数据类型的内容，个人感觉需要自己理解。

2-9：前面3个是错的，最后一个是对的。

2-10：对于local_int，这是一个定义在函数体内部的内置类型变量，将不会被初始化。而对于local_str来说，这是一个类，会非显式初始化为一个空串。

2-11：a)定义；b)定义；c)声明。

2-12：a)非法；b)合法；c)非法；d)非法；e)合法。

2-13：j = 100。

2-14：合法。输出 100  45.

2-15：a)合法。b)不合法，不能对字面值常量进行引用。c)合法。d)不合法，引用必须初始化。

2-16：全部合法，只是会执行强制类型转换。

2-17：会输出两个10.

2-19：引用不是对象，而指针是一个对象。

2-20：求i的平方。

2-21：a)非法，指针类型不对。b)非法，没有使用取地址符。c)合法。

2-22：第一行：当p不为空指针的时候为真。
      第二行：当p所指的对象内容不为零的时候为真。

2-23：不能，编译器不负责检查指针是否指向了合法有效的对象。

2-24：void类型的指针可以指向任何类型的对象，但是long类型的指针只能只想long类型的对象。

2-25：a)ip的类型是int*，i的类型是int，r的类型是int&。b)i的类型是int，ip的类型是int*。c)ip的类型是int*，ip2的类型是int。

2-26：a)非法，const必须初始化。b)合法。c)合法。d)非法，const类型变量的值不能更改。

2-27：a)非法，不能对字面值常量进行非常量引用。b)合法。c)合法，可以对字面值常量进行常量引用。d)合法。e)合法。f)非法，使用方法不对。g)合法。

2-28：a)不合法，cp未进行初始化。b)不合法，p2未进行初始化。c)不合法，常量ic未进行初始化。d)不合法，p3未进行初始化。e)合法。

2-29：a)合法。b)不合法，p1和p3所指类型不一致。c)不合法，类型不一致。d)不合法，类型不一致。e)不合法，p2不能被再次赋值。f)不合法，ic不能被再次赋值。

2-30：v2是顶层const，p2是底层const，p3既是顶层又是底层const。

2-31：第一句合法，第二句不合法，第三句合法，第四句不合法，第五句合法。

2-32：不合法，应该为int *p = nullptr。

2-35：i为整数常量，j为整数，k为整数常量引用，p为指向整数常量的指针，j2为整数常量，k2为整数常量的引用。

2-36：a为int,结束时结果为4，b为int，结束时结果为4，c为int，结束时，结果为4，d为int&，结束时结果为4。

2-37：a为int 3，b为int 4，c为int 3，d为int& 3。注意，decltype不对操作数进行求值。

2-38：相同：int i = 4;auto a = i;decltype(i) b = i;  不同：const int i = 4;auto a = i;decltype(i) b = i;。
