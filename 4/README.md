4-1:
105

4-4:
((12 / 3) * 4) + ( 5 * 15 ) + (( 24 % 4 ) / 2 )

4-5:
a) -86    b) -18    c) 0    d) -2

4-6:
x % 2

4-7:
计算的结果超出该类型所能表示的范围。

4-9:
cp不是空指针，并且cp所指内容不为空时为真。

4-12:
i不等于j的时候，k大于1为真。
i等于j的时候，k大于0为真。

4-13:
a) d=3.0 i=3    b) d=3.5 i=3

4-14：
第一句出错，42不是左值，不能被赋值。第二局正确，条件为真。

4-15:
类型不同。应改为 pi = ival = dval = 0

4-17:
前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。

4-18:
使用前置版本结果会出错，在第二个位置开始，而且不会再该结束的位置结束。

4-19:
a)  ptr不是空指针，并且指向的内容不是0    b)  改为 ival && ++ival    c)  应该改为  vec[ival] >= vec[++ival]

4-20:
a)合法，解引用iter，并且将iter向前移动一个位置    b)不合法，string对象无法+1    c)iter解引用之后的string对象是否是空字符串    d)和c一样
e)不合法    f）iter解引用之后是否是空字符串，之后再将iter向前移动一个位置

4-23:
类型错误

4-25:
-7296

4-26:
有些电脑上unsigned int 有可能比32位小。

4-27:
a) 3    b) 7    c) 1    d) 1

4-29:
第一条输出10    第二条输出1

4-30:
a) (sizeof x) + y    b) sizeof(p->men[i])    c) (sizeof a) < b    d) 无需改变

4-31:
前置和后置效果一样并无影响

4-32:
当范围没超过的时候运行循环体内的语句

4-33:
若someValue不为0，结果是y+1，否则结果是y—1

4-34:
a) fval转换为布尔类型    b)转换为double    c)转换为double  

4-35:
a) 'a'先转为int，结果再转换为char    b) ival先转换为double，ui转换为double，最后结果转换为float
c) ui先转换为float，结果再转换为double    d) ival先转换为float，然后和fval先转换为double，最后结果再转换为char

4-35:
i *= static_cast<int>(d)
