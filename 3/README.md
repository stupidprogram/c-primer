3-3：
string类的输入运算符在执行读取操作的时候会自动忽略开头的空白（即空白符、换行符、制表符等）并从第一个真正的字符开始读起，知道遇到下一处空白为止。
getline函数会保留输入时的空白符直到遇到换行符为止（注意换行符也被读了进来），然后把所读的内容存入到那个string对象中去（注意不存换行符）。getline只要
一遇到换行符就结束读取操作并返回结果，哪怕是一开始就是换行符也是如此。如果输入的是一开始就是换行符，那么所得结果是一个空的string。

3-7:
这里使用char是可以的，因为每一个元素都是char。

3-8：
当然是范围for循环，因为省力，不用考虑范围，虽然while和传统for使用迭代器的时候也不用考虑范围，但是占内存啊。

3-9:
合法。输出结果为空。

3-11:
如果语句没有改变s的值便合法，否则不合法。

3-12：
a)正确。 b)错误，类型不一致。 c)正确。

3-13：
a)0    b)10    c)10    d)1    e)2    f)10    g)10

3-18:
不合法。将第二行改为
ivec.push_back(42);

3-19:
1    vector<int> vec(10,42);  2    vector<int> vec{42,42,42,42,42,42,42,42,42,42};  3    vector<int> vec = {42,42,42,42,42,42,42,42,42,42};

3-22:
for (auto it = text.begin(); it != text.end() && !it->empty(); ++it)
{
    for (auto &i : *it)
    {
        cout << toupper(i) ;
    }
}

3-26:
没有两个迭代器相加这个操作。

3-27：
a)否，buf_size不是常量表达式。  b)可以  c)否，txt_size()不是常量表达式  d)否，大小超了。

3-28:
sa和sa2是其中的内容是空串，ia是10个0，ia2未被初始化，内容未知。

3-29：
不够灵活。

3-30：
起始位置是0，大小超了1个。

3-33:
其内的初始值可能不为0，最终导致结果出错。

3-34:
只要p1和p2合法，语句就合法，功能未知。
